So I guess you may be sitting there wondering about the title of this talk, perhaps thinking to yourselves "is he here seriously going to talk to us about Loving Legacy Code? Surely there is a mistake? There appears to be a mistake."  Just hold your fire, okay.  Yes, you may be thinking, "how on earth did this talk get selected?" But it did.  So let me ask you this question: Let's have a show of hands, how many of you love legacy code? Okay.  Thank you.  I'm going to assume that, well, we are in Australia
after all, so all of you who raised your hands did so ironically?  But that's okay because if I'm honest with myself, I don't really love legacy code either.  However, I do think it deserves more
respect.  After all, it is probably paying for your wages right now.  And I think it does deserve
more love.  But let me be clear, I'm not here to convince you that you could unreservedly love legacy code all the time.  Rather I would typically like to share with you ideas that may help you love legacy code more.  To begin with, how should we approach this topic? Starting with, well, what is legacy code after all? How do we define it? Is it just old crofty stuff? Or is it like Michael Feathers 10 years ago suggested code without test?  If I think about that, I think that would make a code base qualify as legacy because it impedes change.  But I think there is other way as code base can impede change.  For example, if it has got poor internal design or a cumbersome test suite.  So I define it as code that impedes change in any way.  Another question to ponder, why
do we react so negatively at the prospect of working with legacy code? Could it be compilation of technical debt over a period of time?  Because as band-aid solutions are applied, it leads to
poor internal design.  Classes and methods can become too large, complex and unwieldy.  It can
become very challenging to decipher what the code actually does.  Readability is so important. Test suites can be more frustrating than helpful and take hours to run.  We may have some tests that pass sometimes, and at other times fail for no apparent reason.  Then again, of course, as developers - typically not when working with legacy code - have the opportunity to add the latest bit of shiny technology to our CV.  But I'm going to suggest to you that there is another path to develop a happiness.  Sure, exploring new technology is fun, but imagine a poor neglected code base that has been left to rot and you have the opportunity to nurse it back to good health, by giving it some much needed tender loving care.  Sure, it can be frustrating.  It can be character building.  In some cases, the code may be beyond help and may have become so decrepit and pungent that the kindest thing to do is to put it out of its misery.  But most legacy codes are nowhere near that bad.  We'll talk about how to nurse them back to health shortly, but the
original developers, are they still around? If so, it may pay to ask them some questions about the history of the code base.  You might be surprised what you learn.  Even if you don't have the opportunity, it is important to respect the original developers, understand why they may have made the choices they did and learn from the history of the code base.  Let's move on and consider how we can improve the legacy code that we are dealing with.  A logical place to start with is identifying some pain points.  Now, you might think let's start with the code.  I would suggest rather than do that, make use of customer feedback, whether it is requests for new features or reports of problems, and use that opportunity to improve the code at the same time. Then again, customers won't always tell us about problems that affect them, will they?  So in this case, tools like New Relic or Roll Bar will help.  At the same time we can prove the quality of
the internal code as we attend to those problems.  I am sure we are all familiar with the scenario where a developer is frustratedly cursing out loud as they try to understand what a particular
piece of code does.  That's an ideal opportunity for that particular developer to improve the code
so that a developer in the future has a better time trying to make sense of the code.  As well, we have got to be mindful that practically sometimes developers are under pressure to get fixes out into production, they are not necessarily going to pause and put in place those measures to improve the code.  But we do have code quality tools that can help identify areas of the code that need some tender loving care.  So, consider that we've identified some pain points.  How do we go about improving the code? What techniques can we use? Sadly, we can't always assume that the code base is another version control.  I have come across it in my time, even after the advent of Git, I have seen a Rails application, so if that is the case with your code base, get it into a Git repository as soon as you can.  Thinking back to Michael Feathers, if the code base has no test, this is a show-stopper too. To refactor safely, we know you need to have automotive tests.  As we are introducing those tests we may think of introducing feature tests, end-to-end tests.  Is that the best thing to do? I'd say we should be concentrating more on unit tests.  Of course that then

raises the question what is a unit test.  There is plenty of debate about that question.  Read an interesting book by J Fields, where he distinguishes between solitary unit tests and sociable unit tests.  The solitary ones are those isolated.  So they will enable fast feedback and the most useful. We should be aiming to have as many of those as possible in order to facilitate developer flow. Another example of that is configuring guard to automatically rerun tests by the cochanges we make.  We need to break dependencies in the code.  It will improve the internal quality of the code, of the design.  But having introduced some tests, or maybe inherited a legacy code base
that already has a large suite of tests, we will need to nurture the tests and constantly reassess the value of the tests, we shouldn't just keep on accumulating it.  Think of each test in business
terms.  Is it providing sufficient value for the cost that it requires to keep maintaining that test? In some cases we will need to remove tests.  At times, in my experience, feature tests are a good
example of tests that we should consider removing if they are becoming too troublesome.  After all, they take longer to run, they tend to be more unreliable and it is interesting to note that in
J Fields' book he recommends for an application to have no more than a dozen smoke tests. We'll also need to nurture our CI builds, for example, if we have inherited a test suite that takes
hours to run, split it up into several steps and run them in parallel.  Or if we encounter tests that fail unexpectedly, we find that they're failing in a non-deterministic fashion, take them out of the normal build stream and attend to them, obviously, within a reasonable period of time, either
fixing them so that they pass all the time or getting rid of them.  So we can now picture the place where we've come to, where we have some tests in place and we can refactor.  As we do so, we'll
have to make judgments about which refactorings are going to bring us the most benefit.
Because there is rarely a budget that will provide the opportunity for us to refactor ad infinitum to our heart's content.  And be aware of separating concerns, and be aware that Rails doesn't
always necessarily guarantee a separation, a good separation, of concerns to us.  For example,
thinking of Rails models classes.  If you think of this example, here is an example of a Rails class that's accumulated many methods over time.  This is from a 7-year-old Rails application.  You
can guess it is what is known as a god-class and way too many methods, 104 to be precise.  So it is a pretty safe bet that this is a class that should be analysed and refactored and a lot of the
methods moved out to, perhaps, service classes.  But it is also worth pondering what are best practices.  I mean, that situation probably came about because of the so-called best practice of several years ago, having the recommendation of having skinny controllers and fat models.  But
it is worth thinking about the reality what is considered the best practice today may not be considered optimal in several years' time.  But when it boils down to it, we are aiming to make
that code easier to work with, easier to maintain.  And to do this, we will probably want to be
endeavouring to simplify design.  This could bring us to this following set of design rules that were originally codified by Kent Bec, one of my software heroes, and revisited in Corrie Hane's
book.  And it is worth noting the third rule is concerned with knowledge duplication rather than
simple code duplication.  Corrie alludes to a number of points by JB Rainsburger, and he distills it down to this statement.  If we strive to remove duplication and improve names in smaller cycles and stick with that guiding principle we will end up with much better code and usually less code to maintain.  So that's a written.  It has got another side effect.  It is often easy to underestimate the satisfaction of transforming bad code into good code.  A job has been well done, we have made the code easier to understand, test and generally in a better state for future developers.  Other opportunities arise when working with legacy code.  There are good things that you can be involved with.  For example, in a team you discuss what your team considers a
good internal design guideline, perhaps engage with members of your organisation outside of the dev team in business groups to maybe examine a subsystem or feature that is proving a little
troublesome and jointly arrive at a better system design.  So these are, I think, really challenging
and rewarding opportunities that arise from working with legacy code that don't necessarily arise when working on greenfields projects.  Of course, tools can be of great benefit to the fallible brains of developers.  Learning where I work, we are making quite good use of coclimate, it is proving useful for us, not just in measuring code quality but also test coverage.  But there are open-source tools to consider as well.  Like Ruby Cop.  As I mentioned before, as a team you might decide what are your code guidelines? And you can configure RubyCop to help the developers along that path.  If you look at the Ruby toolbox site and the code metrics category you will find more examples of helpful open-source tools, open metric tools.  Another thing to consider, it is worth going that extra step and including, for example, RubyCop in a step in your build every time you do a build on your CI.  Let's switch focus to managers and consider that obviously there are limits on how much can be invested, how much money can be spent maintaining and improving legacy applications, but we need a balanced approach.  Adequate maintenance requires time and effort, technology does need to be updated and upgraded. Technical debt needs to be recovered.  It all takes time.  So don't plan with a blind spot.  Budget

for maintenance.  Be aware there will be situations where the legacy code base has become too difficult to work with and it is time to make that decision and that calls to migrate away, perhaps gradually, and hopefully the new code base will have a better history.  I'm guessing that many of you in the audience will be familiar with a lot of the suggestions I have been making.  But I think there is an even more important aspect, that is the attitude which we bring to working with
legacy code.  Starting with a management perspective, as well as acknowledging the time and effort that is required, we need to be mindful that there are tools that are not open source and
therefore require an investment.  For example, and this is a true story, your developers may have
been struggling and got to the point where they decided, "No, Jenkins, he is just not cutting it any more as a CI server.  We have been evaluating this new investment and it is a tool called
BuildKite."  It actually happened.  Fortunately, our manager made the wise decision and
authorised the expenditure.  But as managers, it is important to respect your developers because, after all, they are trying to improve the business via improving the code.  One way of showing that you respect them is by acknowledging that at times it is wearing to work on legacy code support.  So share that production support role around the team.  Enable everyone in the team to
get a good appreciation of the code base and where the challenges are.  Developers, it's your turn. How can your attitude improve, perhaps? Knowledge in the hand of one developer is obviously a risky scenario.  So I know I've been aware of that situation, not necessarily acknowledged being
in my head, but within a team context, many times in my career.  Particularly if you are that person that has got a lot of knowledge and isn't perhaps shared well enough around the team,
make the effort to spread that knowledge throughout the team, because that is going to help
everyone.  Speaking of collaboration, I can recall back in the 1980s, I was, well, not so much privileged, but had the opportunity to use an approach called structured walkthroughs to review
code.  Fast forward to today and thankfully we have GitHub requests which offer a fantastic
opportunity to collaborate as we are developing features.  So it ponders the question, are you making the most of GitHub pool requests and using them to their best potential?  I think so far I have been focussing on mainly the past and the present, but are you giving sufficient focus to future developers? For example, we mentioned non-deterministic test values before.  If you commit some changes unexpectedly to you the build breaks on CI and you think it is nothing to do with the work I have been doing, you run it locally, you determine it is a non-deterministic failure.  The temptation is to click the button to rebuild and hope it goes green the next time.  It may get you out of the situation in the short term but perhaps it is not helping other developers in the future.  Maybe that same problem will come back and bite you.  So a good idea to make the effort to at least start the process of fixing it and making life easier for the developers in the future.  Another important aspect, I think, is the language that we use as we are working with legacy code bases.  The sentiment, "what were they effing thinking when they wrote this" is probably unhelpful.  We should remind ourselves when they wrote the code that we are now struggling with, they, in most cases, wrote with the best of motives.  Life throws up a variety of circumstances that affect people when working with code.  So it is worth reflecting on the constraints that have existed since the first line of code was written in that application.  This should be self-evident but as programmers we like perfection, but remind ourselves no program
is perfect.  Yep, we should be appreciating that our managers have often a better perspective of the business and how the code supports that.  So it is important to use them as allies rather than fighting against them.  Respect that they are under pressure too.  So let's turn, finally, to some metaphors that may help us with our attitude.  We are talking about nursing an application back to a healthy state.  But I'm sure many of us at home may have a garden.  I don't know how many
would be in pristine condition, I know my garden isn't, but I do manage to keep it from becoming horribly overgrown with weeds.  We talk about that gardening metaphor, it applies well to software.  Or at home, there is the view of a need for a new kitchen or convert part of a room into a bar, or maybe as a reality the shower is leaking and it needs fixing.  There is going to be a need to compromise and the same is true of software.  We can't pretend we will fix all the flaws in the code at once.  All in all, attitude is very important.  Hopefully I've convinced you that working with legacy code needn't be a prospect you want to run away from.  It can be rewarding, provide you approach it with a helpful set of techniques and the right attitude.  Considering those that have been involved with the code so far, they are working with it now and will be affected by it
in the future.  Respecting those people, if we do that, I'm sure we'll feel better about the code as a result. So thanks for listening.  I hope that by sharing some of these ideas I have shed some light on how you can learn to love legacy code more.
