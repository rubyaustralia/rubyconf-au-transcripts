Thank you so much for hanging in here with the gorgeous weather.  I know it is nice outside, I really appreciate you coming back from the break.  I was picturing an empty room and everyone outside having a beer.  I am excited to be here and show you a new talk.  You the first ones to see it and the only ones to see it in the 20 minutes.  20 minutes is an awkward time slot I have discovered, and excruciatingly difficult.  I have never done a 20 minute talk before.  Because it is new, I didn't have 35 minute one to cut down.  It is from scratch.  I was looking through the older talks and no matter how long they were, it took me 20 minutes to get to the first thing I wanted people to remember.  So what that told me and what my experience writing this talk has born out in 20 minutes I can only say one thing.  So when I was writing the talk I had to decide of all the talks I could make, and I could talk about this for several hours, which is the most important? It remains to be seen if I picked the right one.  I am the chief consulter at DevMynd in San Francisco.  Tech industry is killing the soul of the city.  I am part of the problem and being up there and saying fewer! Fewer hipsters! I do a lot of paraprogramming and help people to refactor large code basis.  I didn't raise my hand when Keith asked who liked
it yesterday.  You can see the scars and battles that have been fought and won.  It is like a
tapestry with hidden stories woven en into the git log.  I have side projects, one of the directors of
Ruby, which means I run Ruby conf.  It is not too late to get your talk in for Atlanta in April.  I founded the board of RailsBridge.  I also do bridge foundry stuff, pretty cool.  We have closure bridge and mobile bridge which is really neat.  Despite the slides, this is not a talk about farming. It is a talk about service-oriented architecture, are you scared? We have had so many already.
You may have noticed Rachel did a great talk about service-oriented architecture before lunch. You may have noticed we have many of the same side projects, and we both live in San Francisco.  It is not like we don't talk but it is not until I got here yesterday it occurred to me to
ask her what she was going it talk about.  I had a moment of panic that we were going to have the
same talk and since I'm after lunch I would be the loser.  She set me up good.  It is a talk about object oriented design.  These are two bits of jargon that are intimidating.  People have different
ideas. So I am going to give you my definition for each one and then we ask explore why they
are interesting.  Starting with service-oriented architecture, it is trendy.  I have a friend trying to raise money for her startup right now so she has got a pitch deck she takes.  She got a meeting with one of the big name CVs and she was about three minutes into meeting and just gotten to the point about monetisation and he interrupted her in the middle of the sentence and said, "Are
you going to do SOA?"  She said it in a nice way, she is good at talking to VCs which is why she does it but she said, "Are you fucking kidding me?"  It is one of those things people know what they mean, like the cloud, it is a term that doesn't mean anything any more.  What it actually is and I am going to tell you exactly what I think, everyone starts with one Rails app and one repository, it runs the backgrounds jobs, take as few API calls, for the most it is fine.  But then there are the ones that are successful.  SOAs is always prompted by growth, either growth in traffic that requires one to be different or growth in team size that makes it difficult to work on the same code base and at the same time.  So SOAs involves identifying separate responsibilities and in their own code bases with setups and ending up with an app that does fewer things than before.  It is driven by growth.  When you move towards service-oriented architecture, it is not because of moral impairment or because your VC told you to but because you are feeling the
pain that service-oriented architecture is meant to address.  So that is SOA.  Let's talk about object oriented design.  Object oriented design is often abbreviated ODD.  It is an older idea, at least among our generation of programmers.  As a result it is perceived by people as being academic.  There are some very academic definitions of OOD floating around but it is a very simple idea.  Object oriented design is how you decide where to put code when you need to write it.  That's really it.  Faster or a new method.  But people think about it being academic because they picture this.  You have an app to build so you decide up front the names of the classes you want and then you decide how they all talk to each other.  And then the rest of it is just sort of filling in the details.  You fill in the methods you think you need and working towards the grand plan in your head and at some point when the code looks like the design, you get a gold star and

you are done.  But that's not what object oriented design is.  Because this never happens.  People think it should.  But it never does.  They think it should, largely because of this.  You may have heard this before, solid.  It is an acronym that puts five phases together.  First the single responsibility, each class has a single reason to change.  Then we have had open closed principle, it is hard to explain.  The substitution principle, segregation, dependency, they are useful to
know.  I recommend you look at the Wikipedia page for these at some point.  However, in my opinion they have very limited utility.  The solid principles decide what the code should look like
when it is done but they give you no guidance to get it there.  In the absence of that kind of
guidance many people assume object oriented design means coming up with a design, a priority that fits all these principles.  But what object oriented design actually looks like in the wild is
quite different.  At the beginning you have got rough ideas, concept you want to model, you fill
in stuff and at some point you notice the contract model is getting a little large, hard to work with, too many things, too many responsibilities.  So you take a look what is inside it, separate the responsibilities into its own class and again, not because it is some moral imperative or because Uncle Bob told you to but because you are feeling the pain that object oriented design is
supposed to address.  The design of your application is those dozens of decisions you make every day, from small scale to large scale.  It is not a prespecified framework that makes the decisions for you.  Design comes from the bottom up, in other words, it cannot be top down.  So it is a legitimate question to ask at this point, why not? Why can't we do this? The answer is we simply don't know at the beginning what responsibilities the code will have.  The only thing is to write
it, put it somewhere and move it when it is out of place.  Failing to do this is how Rails get in trouble and you end up with a monolith.  Think of the largest active model you are working on.
This is an E commercial spree app.  Not picking on spree, it was just there.  Let's look how big this file is.  This file itself has 650 lines however it includes a bunch of modules down here we
have to count.  So the total is just about 1100 lines.  Who can beat that? Who has got a model with more than 1100 lines? More than 2,000 lines? More than 5,000 lines? Wow! Yeah, I've seen
it.  It does exist.  I am willing to bet the largest model in your code base is the one that needs object oriented design.  The rest of the code fitting on one screen doesn't matter.  There is a
scatter pod where one acts as an complexity and one acts as a churn.  That's my definition of service-oriented architecture and object oriented design.  When you look at those boxes and lines diagrams it seems so clear, right? You just find the boundaries of your responsibilities and make
them formal.  But I think Rachel covered earlier quite well delineating the boundaries of a single responsibility is surprisingly difficult.  OOD is the same way.  You read a book, you are ready to
do the right thing and you sit down in front of your Rails app and you don't know what to do.
Design is easy starting from nothing.  Design is really hard when you try to refactor towards it. These two problems are hard for exactly the same reason.  That is, figuring out the boundaries of
a single responsibility is pretty hard.  That's true whether you are trying to pull out a service or
reduce the size of a class.  So what do you do? Solids shows amazing places where the code can be.  It looks pretty awesome but gives us no road map for getting there.  What is our roadmap? How do we know which things to separate? I call this the phone booth in the garden problem. Maybe this was once the right place for a phone booth, maybe there was a sidewalk or a building but at some point the landscape changed.  We get used to it, the phone booth has always been there so we don't notice the incongruity but we need to notice it again.  We do have some ways to help us see the phone booths and they are code smells.  It was made popular by Martin Fouler, they are described as surface indicators in code that indicate deeper problems within.  Some people call them icebergs because only 10 per cent of the iceberg is above the water.  We show you for scale, this is a lighthouse, this is a really big iceberg, if that is 10 per cent, yeah, there is a lot of ice under the water.  So for me, it is a sign that I am mixing responsibilities.  They are the clues that tell me what objects I need to make and I to put my seams.  Let's look at an example. Duplicated codes is the one we are probably most attuned to and most used to seeing and
cleaning up.  So let's say you have two with these methods.  They are both generating some kind of user readable ID, with slightly different algorithms and prefix.  But it is hard to see where the differences are in this algorithm.  So fortunately, each code has an associated refactoring that will fix it.  So when you have duplicated ideas what that is telling you is there is another class trying
to get out.  The refactoring that fixes this is called extract class.  So you can write a class that encapsulates the idea that is duplicated and then you use that in the places that's you were using it
before.  Now it is easier to see where the differences are in the algorithm and you have made a
class that is easier to test than before.  We have talked quite a bit over the course of this conference about DRY.  Don't repeat yourself.  Many people have said it is the duplicated ideas that are important and not the duplicated syntax.  It is very difficult to tell the difference.  The way I think about it if I can make the duplicated logic into a new class then I should do it, otherwise I shouldn't.  So if you can't dry it out with a new class, if you can make it into a new

class, it tells you it is the same concept that you can reuse.  We have the idea here.  There is other one to get familiar with and locate examples in your own code.  Most have fantastic names.  The official name of duplicated ideas is shotgun surgery, which describes having to operate in
multiple places at once in a code base to make change.  And then inappropriate intimacy, when one class knows way too much, the logic is to move it around.  Then passing two or more
parameters together.  The factoring to fix that is to move it into one.  Any time you have to use
LSIF after yourself if you need it.  So these are the guides we use to help us see opportunities in our code to improve the object boundaries, that guide us towards solid code.  So the question is can they also help us make decisions where to put service boundaries.  I think they can.  But they do take different forms in the SOA world.  The first one that I have identified is shared data.
This can manifest itself in a number of ways.  The most obvious is sharing a database.  Two are not independent if sharing.  You can't have separate databases that synchronise.  A nice trick but
it doesn't work.  This is a smell that tells you services are not largely independent.  Next one is
shared business logic, if you are tempted to make a gem that has your models in it, your services are not independent enough.  Lockstep deployed, two services that must always be deployed together.  They can caused by share business data or shared logic.  There are other ways to get it to happen.  Just like code smells, service smells are not clear cut and don't exist in isolation but having a name to put on them does a surprising amount of good.  If you have to pass in one or two things to pass it in, it is doing too much.  Hidden parameters.  And finally a parameter clump, if you are passing two or more pieces of data together there is probably something that needs to go in its own service.  So we have these corresponding, here we go, corresponding code smells and service smells.  The way to fix most of these is that you make smaller classes when you do code smells, you make smaller things that do fewer things than they did before.  With services, the solution is actually exactly the same.  You make smaller services.  A lot of times if you are having an awkward interaction between two services what it is telling you there is a service living in that interaction, there is a third service that needs to live for that interaction to
be less awkward.  I want to leave you with a couple of thoughts.  Service-oriented architecture is a new term for a very old skill.  It is all about identifying responsibilities.  This is a skill you can practise and get better at.  It is much cheaper to learn it in your code than it is to learn it in your services.  Because class boundaries are a hell of a lot easier to change than service boundaries.  It is refactoring into smaller objects that makes it possible.  You have to deal with your objects before you can do services.  Then once you get there, you can use the smells to guide your architecture towards single responsibility services.  If I can leave you with one take away from this is this, make smaller things.  Always.  That's all I have.  Thank you very much.
