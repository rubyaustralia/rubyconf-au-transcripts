Good afternoon, ladies and gentlemen of the jury.  Welcome to today's trial.  Use cases versus the state of Rails applications.  I am your prosecutor, Shevaun Coker. When I'm not prosecuting software concepts, I am the tech lead of the purchase team at Envato, which is the scene of the crime.  Don't worry about taking notes, I have a written transcript of the proceedings which I will share at the end.  As you should know, we are here today to determine the guilt or innocence of use case in proving the Envato application.  It has been charged with reducing coupling.  Increasing the visibility of the features within the code base and encapsulating complex business logic.  I must warn you, I will be showing you some code today but I have kept them simple and relevant so please don't try and run them in production.  Before we delve into the evidence let's establish some motive.  Who here has written or worked on a Ruby on Rails application before? Good.  So the following story hopefully will be familiar with you.  I have been writing it for seven years now and they seem to go something like this.  The business, how businessy they look.  They want you to build a simple Ruby on Rails web
application.  I am sick to the death of the classic Rails blog example so instead today let's go with some kind of digital marketplace where you can buy photos.  First up, you gather the
requirements and luckily at this stage there is just one, a buyer needs to be able to purchase a
photo. So you map out the domain models, you have your photo, your buyer and a purchase and

you implement them.  How? Well, Rails makes it easy, right? You get these three buckets where you can put your code, your models of use and your controllers.  So we create the buyer model, same for the photo.  And purchase is the same and for purchase, we even get our associations pretty much for free.  We then create our controller in a very similar way.  Let's give it a create action and inside we will create a purchase for that buyer and that photo and redirect to the purchase completed path, whatever that is.  And we are done, right? But look how happy the business is.  But you all know what happens next.  Some time later, new requirements arrive.  So the business comes back to you and they say, "Hi, now, whenever buyers purchase photos I also want they get a purchase invoice and I also want that we require the sales counts of these photos and I also want a buyer can review a purchased photo".  Okay, no problem.  We can implement this pretty simply, right? We go to our controller where we are creating purchases and we get the buyer to send an invoice.  We increment the sales account of the photo and we enable the review of the photo for the buyer. The business is happy again, but hang on a minute, it looks like we've got a fat controller.  And everyone knows it is bad.  But there is a simple solution to this
problem.  We be go to the models.  The purchase model doesn't have much, so let's create a method.  We will go back to the buyer and rip the logic out and chuck it in the method.  Back in
the controller we need to call the new method we have created and look it is thin again.  Hang
on, how is the model looking? It is a little fat.  Is that a problem? Let's take a look.  So this method that we have added to the purchase model has added the responsibility of creating purchases and all the associated business rules for creating a purchase.  Now, purchase is already
responsible for persistence because we are extending at the base.  If you think that is just one
line, that's not a big responsibility, have a look at this.  So an empty class that extends the active record base has 214 methods on it.  So that is not insignificant.  Aside from persistent now the
purchase class has additional reasons to change.  So it needs to know about the buyer sending
invoices, incrementing sales accounts and reviewing photos.  This is just all in one method.  So imagine if each method has its own responsibilities.  So fat models have too many responsibilities.  They are already tightly coupled to your framework and you add business logic they are coupled to the domain.  It makes changes harder, more prone to bugs and conflicts and you will end up with huge class files with many public and private methods in them.  So I would like to compare reading a large class to looking up to a telephone pole in Vietnam.  Considering that we write this code one but read it again and again, don't underestimate the value of having easy-to-read code.  We have obfuscated the business logic.  You see the nice buckets and they may reveal the domain models but you don't see the use cases of the system.  Now we have established some context. It is time to meet the use case.  What is the use case? After some research it turns out that like most other definitions in the industry, the term is a bit overloaded. However I did find a definition on usability.gov that I like.  It outlines from a user's point of view a systems behaviour as it responds to a request.  Each use case is represented as a case of simple steps with ginner with the user's goal and ending when that is fulfilled.  It provides a list of goals but as soon as an application gets built the documentation starts to drift from the implementation and becomes less relatable to the code base.  Simon Brown gives a great talk called The Essence
Of Software Architecture where he talks about the importance of living architecture in your code. I now call myself to the stand as a witness to implementation of the use case pattern at Envato.
At Envato we have a large code base with many developers working on it.  Whatever we had, we
needed it to be simple, consistent and conventional to implement.  So a UML use case depicts an entire flow which may involve multiple actions.  We decided to reduce the scope of the
definition and define it as a plain Ruby class that defines the steps.  Our classes are named after
the action the user takes, like confirm photo.  We have a directory for the cases to live under. We created a small module called use case which defines a simple public interface for our use cases to implement.  This module has a class method perform which takes whatever arguments it needs, initialise as new instance.  You will notice it is wrapped in a tab lock, this ensures it is a command method because any return is ignored.  We also define - here is a simple example of a use case, a plain Ruby object named after the operation it carries out.  It includes the use case module.  It has an initialiser which takes whatever arguments it needs.  Inside of perform
methods to happen steps are needed to complete the action and achieve the goal.  In this case purchasing a photo.  These methods are inside the use case and they each call out to another
object to execute the logic.  I will come back to that later too.  Most have a success method which uses active model validations so we can determine the success or failure and respond
appropriately.  Here is a simple exact of a controller calling a use case.  It checks if it was a success.  If it was it goes to the purchase completed path.  I now call upon myself as the defence
lawyer for the accused to recall what went wrong.  I have covered the base idea behind the current implementation, however the design has been a few iterations as we have implemented
more use cases and I am sure there are more improvements to be made and we have learned a

few valuable lessons along the way.  1, command career separation.  It is an important concept in software design.  The idea is to split them into command which are side effects and no return value and queries which are important and return the value.  Originally we ignored the principle and our perform method returned this.  It made the use cases harder to test and refactor.  Sandy Matz said we can create them at our peril.  If we haven't seen her magic tricks of testing I recommend it.  By splitting our functionality into a command level and perform multiple queries, they obey the rule and are easier to test.  We started unit testing the use cases as we normally do but realised we can test the effects it produces and be confident the business logic is correct. Generally speaking, we unit test the classes and layers below the use cases.  We have a smaller layer of acceptance tests at the top to ensure the system works from the front end all the way down.  Here is a quick example of an integration test.  So the subject is the perform method of
the use case and then we can make expectations on the side effects of that command.  For example, we expect perform to change the purchase count and we expect it to send an email that has the subject purchase invoice.  Lesson three is don't put your low level logic in your use case. So this introduces multiple levels of abstraction and gives the use case too much responsibility. Instead, move the logic into specialise objects, call them from the use case with high level commands, this will increase the readability and changeability of your code.  We did this by creating a number of classes, each implementing one step of a use case.  For example, increment sales count has its own object that knows how to count.  Lesson four is don't make the use cases generic.  A key benefit of a use case is that it reflects a single use case of the system.  If it is generic for multiple use cases you lose clarity and context.  We have multiple ways to complete the purchase.  We tried to make one big use case that tried to handled all the payment methods of a user but it was complex and error prone.  We split it up and now they are simple and easy to understand.  I have covered implementation and what we got wrong.  We get a consistent interface, so the use cases all look similar, they have the main method and use the modules so they are identifiable.  We get documenting and readable code.  Each case provides
documentation of an important action in your system.  If another developer wants to know what happened when it is completed they can go straight to that.  These methods are easy to read because they are the same line.  If they need a detail behind the particular step they can go to step and see where the logic is.  Each use case creates a wrapper around a bunch of other objects which implement the low level logic.  The input use case encapsulates everything you need to carry out the action.  Let's say the business wants a confirmation.  We create a new private method that called out to the behaviour and we add it to our method and that is it.  We get decoupling.  The controller has very little logic.  We get a code base that reveals its features.  So
devs can look in one place to see all of the user features of the application.  Before we deliver our verdict, there is a couple of qualifications I would like to make.  I hate cliches so I hope I don't
have to spell it out to you but I want to impress the use case pattern is not a shiny metallic
projector able to stop mythical creatures in its tracks, just think of it as a tool.  The name is a debated topic.  It is fair enough the name is a broader topic.  I don't think the lead architect is a big fan of the term but I can't quite hear him from his ivory tower so I don't know.  There is a few various implementations of the use case pattern floating around in gems.  It has preconditions
and pipelines and interesting things.  My colleague has just released a gem called interaction which is based on the cases at Envato and hopefully over time we can use that gem ourselves.  I came across the interactor gem a few days ago.  It has a slightly different implementation but the intent is virtually identical to our use cases so that is really cool.  So back to the case at hand. After reviewing all of the evidence I think we have to conclude that implementing the use case pattern at Envato has helped us to reduce coupling, to refuse - it is guilty as charged.  This court is adjourned.
