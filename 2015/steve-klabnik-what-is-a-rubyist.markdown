I have a talk for you this morning.  It starts off a little intense, I'm sorry because it is the morning. I am going to use a couple of big words but I pitch this talk as what is a Rubyist.  As Josh mentioned, I am doing less Ruby work but I have some gems but I still maintain the Rails.  But I consider myself a Ruby programmer and I love coming to Ruby conferences and you are my friends and you are great, so there is this interesting thing that happens when you have a career and there is some progression and you do other stuff, so I have been thinking a lot lately about why, if I don't do a lot of Ruby, why do I come to Ruby things all the time?  I have a little Ruby tattooed on my body, that is how much I like Ruby, if you didn't know.  I think the answer comes down to the title of the talk.  What is a Rubyist?  Why I do call myself a Rubyist even though I write less Ruby?  We are going to start with Plato.  There is a
part of philosophy called ontology and it asks the question why kind of stuff is there and what kind of things are there? That is basically all it means, ontology.  There are interesting
subquestions in the field.  I am not going to through thousands of years of philosophy but Plato
came up with the theory of forms.  Why it matters to you, Plato invented oriented programming before it happened.  I also fundamentally disagree with it, which is fun.  Basically the idea Plato had we could declare what stuff exists by certain properties that it has.  So for example a tree has a trunk and a tree has leaves and those leaves are green.  So if you have a trunk and you have green leaves, then you are tree as a random example.  This is the same way the models work in a Rails application.  The user has a user name and hopefully a hash password and a bunch of other attributes that make up what that thing is.  As we know it is very difficult to model the real world in these kinds of applications especially as things change over time.  What happens when your user account goes away and you reactivate it and there is this stuff that can make this kind of modelling difficult.  I think there is a lot of interesting stuff about the concept of time, but that is not this talk so I will shut-up about that now.  If Plato is wrong who is right? I think about the problems through the process called process philosophy which is not about attributes that define identity, it is what you do that defines your identity.  Instead of saying a Rubyist has an attribute for being a Rubyist, have a Ruby account or GitHub account, if you do Ruby stuff and are part of the historical stuff of Ruby as it goes through the ages.  It allows for us to be Rubyists and JavaScript developers and PHP developers.  We don't have to tie our identities to one programming language.  It is a positive thing.  There is one more thing and then I will shut up about it, and that is assemblage.  Once you get away from the idea of central attributes it is hard
to define groups of thing.  What is RubyConf Australia? In a sense, it is all of us coming together to attend it but sometimes people sleep in and miss the first couple of talks or they leave early or come in the middle.  So it is more like an amorphous group of people who shuffle around.  We

are not RubyConf Australia if we miss an extra person or bring in an extra person, it is a social thing we do.  That is the way it is important to think about Ruby and programmers and being Rubyists we have the people who filter in and out and it is a natural and important part of this process.  As someone who is sort of in this process of stepping into and out of Ruby on a relatively rapid basis I have thoughts for you on the way the Ruby community should go as someone who stepped outside of Ruby world to a degree.  I have some perspective for being outside of Ruby world for a while.  That is what I would like to share with you.  Now I am done with the heavy thing, sorry, it is the morning, it is early, I got to slip it in.  What should we as Rubyist do going into the future? I think the most important thing is actually two important things.  It is so hard.  Things are hard to categorise.  The most important thing is to stop talking so much trash.  This ties really into another really important concept that I think we as a community need to understand and internalise and that is we are not actually the cool kids anymore.  I don't know if you have noticed but there are very few startups that brag about using Rails as their competitive advantage.  When was the last time, I almost said the disclaimer, I would never advocate that anyone reads hacker news, first of all.  But if you were to do so for whatever reason, it has been a really long time since there has been a post on hacker news that is
"check out my new cool startup, by the way we are using Rails, it is awesome."  I think it is okay and good in many ways but we haven't realised it is good and okay.  So for example, every time,
and this is - we have made a couple of DHH jokes and I will say the slide presented yesterday with the "fuck you" written on it, certain people who lead our community have set a tone that I
think is harming us.  I'll just leave you to fill in the blanks.  The problem is like every time we
talk trash on Java, people, I can't help but think that, like, we are those Java people that we are making fun of.  Like, in many ways this concept of maybe active record should not be your
consent persistence layer, Java programmers have been doing that for a long time.  Maybe if we
weren't so busy making fun of them we wouldn't have the years of angst about active record and we could have used the thing they already found out was good but we were all too busy making fun of Java.  This also matters because in some ways the JCM and Java might be the future of Ruby.  I don't know if you have seeing the work the team are doing lately but it is amazing, really amazing.  The whole Java 9,000 shenanigans might make Ruby a fast programming language. That is not including the typing stuff that Tom was talking about yesterday, which also is something a big improvement for Ruby.  So I want to get into that more in a moment but there is an important model, it is like a business book, I hate recommending it but it is a useful model to think about it and so does a lot of people because there is a billion copies sold.  It is called Crossing the Chasm.  The guy that wrote it, I totally forgot his name, because I take terrible
notes.  It is about the process by which new technology and new businesses get adopted by the population at large.  So there is sort of this curve, this bell curve that is small at the beginning
and the end and fat in the middle, kind of what an IQ distribution is supposed to be.  I forget the
math formula.  I was so bad at math.  But there's five different groups of people who are involved, five cohorts who are involved in adopting a new technology or a new business.  They are called the innovators, the earliest group of people, the early innovators, the late majority and the laggers.  The idea is the innovators are those people who, I will say a great example is the rust world, which means we are breaking the language every single week.  Sorry.  No person would use it for production because we break it every week.  There is a lot of cool stuff happening but only a small number of people are willing to put up the with crap.  There is the
early adopters.  You start to see people actually using it for real things and the community grows. I think go is a good example of the technology.  There is a lot of people really excited, a lot of people who aren't really interested in using it yet because they want to see how the shakes out, it is not mature enough for their usage or understanding.  So you have more people using it but not everyone.  The reason the book is called Crossing the Chasm because between the early adopters and the majority, there is a big gap.  Technologies succeed or fail based on whether they are able to jump over the gap from the early adopters to the majority.  The reason there is a gap is because some technologies fizzle out, they are not good enough for some reason or something bad happens.  I won't talk about programming languages that have failed that cross the chasm,
because trying to talk less trash.  But if you jump over to the early majority, that's when you made it and you succeed through the rest of the period of history.  I am not sure of a good
programming language that has recently made the jump, but the early majority is something like
40 per cent of users, I think, I have read this book years ago, I am going to make up a number, because 90 per cent of statistics are made up on the spot, right? There is a big chunk in the early
majority and when they use it that is when the conference train starts to get rolling and the tonnes
and tonnes more people use the thing.  It is when it becomes cool but not too cool, you know. Like, yeah, I don't know a good example to put in there.  But it is like, a really great time.  It's one of my favourite times in a technology being adopted because there is vitality, you can get a

job using technologies that are in the early majority and it is popular.  Between that phase, in that chasm is where I think Rubyists think we are but we haven't been there since 2008 or 2009, maybe 2010, I don't want to quibble over dates, time is a social construct anyway.  In my last
talk, right before here at Fosdam, humans don't perceive time as linear but I am going to have to give you this linear presentation anyway.  The late majority is the early majority but it is once it
is stable and rock solid and enterprises.  Enterprises use late technology technology or sometimes
lagger, the last category.  I think Ruby is in the middle.  Ruby is over 20 years old at this point and 10 years old being very popular.  I found myself recently saying I didn't want to use a new technology because Ruby is so much more productive and stable and so many more libraries available and I can get work done and it is nice and easy, right? That is the sign of something in the late or early majorities, not something in the innovator category.  What is funny, in 2009 or
2010 I would have been the person saying I don't want to use the new technologies because they are stable, I want Ruby because there are no libraries, you can write the libraries you want.  I will tell you later the reason I am thinking about it is because I just turned 29.  I am on the cusp to being in my 20s to being in my 30s, it is a scary thing, maybe not, maybe I think about things too often. I remember the hippies who were "don't trust anyone over 25" and then I found another quote that said "don't trust anyone over the 30", soI have been using that for the last four years. But it is really important that Ruby is going through the similar transitionary phase.  I had a conversation saying maybe life is different and I don't want to grow up.  Ruby is in the same phase, we want to break things and not support mature technology and love to be doing cool innovative things but if we don't recognise we are the mature adults who have come of age, Ruby will go away.  I think it is a problem because some of the leadership, who is unnamed, is also not willing to acknowledge the fact.  Jeremy said a long time ago, the Rails 2 to 3 transition is what killed Rails because no JSON.  I don't agree with it but I think there kernel of truth where after that period of time we became the man.  If you stay alive long enough to see yourself become the villain of the story.  Ruby was, fight the power, but we are now the power in many ways.  This ties in with my earlier point about not talking trash.  Ruby is going to survive, I would like to see it being in the same place as Cobalt, but if you are a programmer you have been gainfully employed for the last 40 plus years doing the programming that I assume that you love? I don't really know. I don't know those programmers that well.  I can't say it for sure but I would love to get a Ruby job for the next 40 years, I don't know about you.  But to do that and make Ruby to be around for that long we have to understand how we are changing.  I thought it was interesting yesterday a talk about growing up and coming into management and also a talk about adding static typing, because those things are useful.  Those talks and factoring talks are about how
Ruby is growing up and changing.  But it is important because the assemblage concept and not talking trash, we wouldn't be adding it to Ruby if we didn't know static typing was important.  If
we keep making fun of other technologies instead of using them and stealing their good ideas and
bringing them back to Ruby we will be in our own bubble and become irrelevant.  We need to adapt and change in time, and to do that we need to be a polyglot and do other types of things and bring those things back to Ruby and vice versa.  I have been joking one of the best things I did with Rust is to get Jahooda involved.  We are bringing the things I love about Ruby to the
rust world.  The static typing is the opposite, it is a bidirectional thing, it is us stealing good ideas from other languages, us giving good things to other languages is what we are doing with rust.  It is thought rust programmers would need to write make files.  I don't know if you have dealt with make files but sometimes they are "make me sad" files.  We in Ruby world have a great idea called bundler.  There is some people who talk a lot of trash on bundler but they are part of Seattle RB or don't remember what Ruby was like before bundler.  Rails was very hard to
develop before bundler.  I don't know if you remember installing gems and getting weird cryptic errors, you bring someone new on the team and they wouldn't have the right version installed and
it would take a day to find out.  As many problems as bundler has, you can type in a Rails app
and it starts for you.  When we saw it with the make world with rust files, we thought it needs to stop.  We pitched the idea of having bundler in rust and that's called cargo.  So they were incredibly sceptical at first but now we are like amazed it can be this easy because the programmers are used to everything being hard.  I think the cross-pollination of ideas of Ruby bringing its concepts of ease of use and the joy of programming to languages that haven't had that before and C Bus, plus bringing performance back to Ruby, which is a totally different talk, I think it is important to keep to do that as a community and that involves having a lot of respect
for programming systems and ecologies and understanding and maturity out of ourselves to recognise we are becoming old people and that is kind of awesome in many ways.  That is all I have for you to today.  Thank you for having me here and coming out.  Have a great second day of the conference.  Thanks.
