Hi.  I can't remember what was on that slide so I need to look up from reference.  I'm from the friendly part of America so I like to get to know my audience a bit.
I met some of you beforehand, but it would be a big hand if you could give me your names again,
so I have a bad short-term memory.  I'm never going to remember that.  So, I'm Coraline Ada Ehmke.  As I was introduced, I am in charge of developer happiness at a company called Instructure.  It is about code and processes.  This talk is about I wish the developers before me had done differently.  So I am going to break some taboos today and lose some friends today but I think it will be worth it to spark some conversation.  They're real, they're totally real, drop bears, it's real.  Not scared at all, though.  They look really cuddly.  My talk is entitled
Prefactoring, Getting It closer to Right the First Time.  We are going to have a serious discussion

about the A word.  I have been doing development for about 20 years and when I studied methodology, we had waterfall.  It was terrible.  It is hard to add features to a waterfall project, there is a lot of friction around changing a design.  You fail last and it is hard to fix things.  But there was some good things about waterfall as well.  You had a planned roadmap for where your application was going to go over time.  There was good documentation and design artifacts that captured what the code was supposed to do and why.  So there was some good stuff in there.  I think in moving away from waterfall to what I call just-in-time architecture, we've lost some nice things along the way.  I think the pendulum may have swung too far in the opposite direction.
But we don't have to form a binary thinking about architecture.  Design is not the only alternative and no design at all is not viable alternative, so I would like to look at how to be thoughtful
without over designing.  I like to think of it as creating order from chaos.  I think of it like a
sculpture who sees a block of granite and within that block of granite the sculpture can see the image that wants to emerge from it.  By applying will and discipline and creativity they can create the image out of the raw material.  The natural tendency of a chunk of granite is to turn it into a bolder, which will turn it into a chunk of rock, which will turn into gravel.  The natural code of is to turn into legacy, something that no-one wants to touch, and slide into entropy. Architecture is about creating tension.  Being thoughtful about managing the tension is really important because whether you realise it or not when we write code we make compromises.  I would rather make a compromise consciously upfront than discover I have made an unconscious
compromise down the road.  Gretta said that music - music is liquid architecture and architecture is frozen music.  Music takes a lot of technical skill but it is not technical skill alone that makes music beautiful, it is collaboration, composition, the mixture of melody and talent and all other things.  That is what makes it beautiful.  I think architecture can be beautiful by applying the same metaphors but today it tends to be utilitarian and brutalist, something we tolerate.
Deliberate architecture is not fashionable anymore.  But what happens when we disregard architecture altogether? Do we end up with better software? I am going to show a case study, a cautionary study, if you will.  The last project I worked on was called Pandometer.  We did it in several phases.  We started out with design comps.  So we looked at the graphs that would look at code quality we needed answers to.  We spent a lot of time iterating on the design, about the kind of data we were going to represent and how these would interact with it.  The second was a series of command lines.  I recommend you check this out, we wrote it, it detects and maps out coupling between classes, both afferent and efferent coupling.  There is Fukuratsu, churn, some
other tools we brought in there, we had wreak and other things.  So third phase was PandaPowts, basically a job runner that you can plug tools into that you could execute and gather output from them.  The point of it was how are these tools, we are going to plug in and gather metrics and chart them over time.  We had two teams at the front end.  A lot of workers at the front.  So when it came time to make the front end functional, we had fixture data we served up through Rails controllers to a JavaScript NVC which used 34 visualisations.  All good.  The pandometer ADI was next.  It was a way for all the command line tools to get posted to the pandometer.  We decided to tie it all together.  It was time.  So it goes into the database.  This was the response cycle that we got.  Painful, painfully slow.  So what happened? We had queries like this.  If you look carefully, we are doing a recursive query.  It is not easy to test it, let me tell you.  We had a generic measurement model.  Let's look what it looks like.  It is raw JSON.  A 2 point font, that's a record.  202,000 characters of JSON.  I look at that and can't understand it and read it, I'm not comparing it with Ruby but that's what we were doing.  Sprint 7, data model, we should have thought of that.  We put ourselves in a situation where we had optimised for rights and a
reporting system should be optimised for reads.  I found that profanity and rework go well.  It is hard to take something apart once it has been glued together.  We spent so much iterating on the front end, we had to do a lot of rework.  I don't think the experience of my team is unique.  I think to all degree we fail in some way.  How does it happen? We do economical development, we do Rails by the numbers.  We are in a hurry to produce an MVP.  We build houses on shaky foundations and spend tonnes of money on expensive paint.  We treat a back log like a stat and never look down to see what is coming next.  Lots of hands on the code and no overarching
strategy to do an implementation.  We spend more time optimising style sheets than data models. We need a balance between the front end and the back-end work.  To make things more
complex, we are increasingly using JavaScript NBCs.  That framework is great because it means you can get it wrong twice in two different places in two different languages.  Awesome, right?
There has been some talk about service orientated architecture.  SOAs will not save you.  What it will do is break it into 10 pieces and add latency on top and you will have the same problem in
10 problems.  We can determine the success or failure quickly.  It falls apart with a lot of moving parts and people working independent vertical slices.  We hope in the end everything comes
together right.  Unfortunately, it rarely happens.  Why do we do things this way?  I think a lot of

the development we do is guided by fear.  Fear of premature optimisation.  What is the opposite? In my experience it is no optimisation.  If you don't make time for optimisation as part of your process you are not going to get to it later.  Garry Burnheart said we will cross that bridge when
it is burning beneath us.  Nobody wants to be accused of gold plater but the engineer who focuses on the structural integrity of the bridge is not guilding.  It is planning for extendibility and
maintainability.  Opinions of what the code looks like don't translate in concrete advice.  We
don't have a lot of patterns to follow that are good structures for object models or applications.
In every text editor there is a drop-down editor that says "file, new".  We are terrified.  We would rather open up an existing class.  We don't have to pay more for more files.  It doesn't work that
way.  It is harder to delete a file.  I couldn't find a quote to support that point so I made it up. Attract as many methods and dependencies as possible.  Costers are expensive and aspire to
godhood.  It doesn't happen accidentally to make them good organisms.  A lot of talks have been about monoliths and how to fix them but with architecture our code tends to monolith.  Without
planning on design you will be patching and duct taping and increase complexity and coupling and you are building the monolith of tomorrow.  Duck  Norton.  The problem with quick and
dirty is the dirty remains after the quick has been forgotten.  We make compromises on the way and it undermines the overall effort.  Fear of missing deadlines.  We bring it on ourselves.  We assent ourselves to deadlines that don't allow us to write the code we want to write.  What if we
start treating them as constraints and treat them as milestones?  What would happen to the quality of our code.  No time to do it once twice, well, do it wrong both times.  That's not the
way I want to write code.  Imagine building a race car and focus on the speed of the car at the
end of the project if and when it became a problem?  Doesn't work, trust me.  This is not a superNova, this is where all our code is going unless we are deliberate about its design.
Acronyms, friends or foes? As developers we love acronyms.  They are fun.  They are cognitive
shortcuts.  They also make us feel safe and distances us from decision-making and reduces the risk of our being wrong.  But at what cost? DRY, I think is one of the most overused acronyms.  I have seen developers jump through hoops where they use yield blogs to prevent copying three lines of an iterating and start doing conditionals and this stuff.  I write code for humans first and machines second.  So DRY is not about repeating code, it is about not repeating an idea, not repeating a semantic entity, it is about clarity.  YAGNE.  It is not about managing code, it is
about managing yourself.  It is a way of avoiding the paradox of infinite choice.  We can't predict the future, we say, right.  But we also can't afford to pretend the future is never going to come. There is nothing wrong with being a bit prepared.  Don't code as if today is the only day it is
going to be in production.  It is going to be there long after you have gone.  I want to propose a
couple of new acronyms, leave designs open.  Intuition is great, I use it as I code but I tend to remember the times I was right and totally forget the times I was wrong.  And YAGTE, you ain't
going to get to it.  Temporary code is the longest at all.  Search your base for fix me and to do.  If
refactoring is not baked into your process and do it as you are going along, YAGT.  What can we do? Realise that today's quick fix is tomorrow's legacy code.  The word legacy outside of the programming world is a gift from one generation to another.  Think about those who are going to come after you.  Do what you can to make their lives easier.  You don't want to be on the other side of a blame.  Consider the code you write today as a gift to your future self.  Keep the big picture in mind.  Fixing a method is easy.  Fixing a design is really hard.  We have really well documented strategies in place for refactoring a method or restructuring classes or doing things like that but not really good patterns for fundamental aspects of our architecture.  It means we have to give ourselves room to fail, create expectations and learning opportunity about the fundamental building blocks of our applications.  I hear developers say naming things is hard. Naming thing is not hard if you know what the object you are working on is doing and how it fits into the narrative that is your application.  It is not naming it that is hard, it is understanding it
that is hard.  Once you understand what the role is the names should come easily.  Rails developers, we tend to think tables before we think objects.  I think it is a poisonous thing.  I
want persistence to be a service to my application not the central aspect of my application.  It
leads us down a bad road, basically defining the thing I am making.  Designer object model based on, not on abstract principles of how we can normalise it in the database but how it is going to answer questions your users will ask in the database.  As we spend time developing the front-end applications, if we make our data models in sync with the front ends we will create a structure that answers questions more easily than if we focus completely on normalisation. Recognise small decisions pile up and can have a massive effect.  If you are wrong 1 ,000 times
on a small level or once on a big scale, that 1,000 times wrong is much harder to undo than being wrong early and giving yourself a chance to iterate over your design.  Collaboration over code
reviews.  I don't like pole requests and I am probably losing friends as I say that.  By the time
code comes in a request, 1,000 micro decisions have been made how it will look and function.  If

you have an alternate idea or better or a suggestion to make it better, by the time it comes up to a request you may be reluctant to share that kind of feedback because someone has put a lot of work into it already.  You don't want to make them feel bad about the work they've done or
defensive about the code they have written so we accept code that is technically sufficient instead of excellent.  Thus quality begins to slide into entropy.  We need to learn to fail safely.  We need
to prepare to be wrong.  We need to embrace being wrong.  Being wrong is creating learning
moments for us.  Do it as early as possible, don't wait until the end.  That's what happens with waterfall, getting wrong at the end.  Getting it right the first time is not a goal of agile development, it is the goal of waterfall development, don't fall into the same trap.  We all know it and don't say it out loud very much, there is never a refactoring phase.  You will never have time in the future to fix the duct tape that you are putting on your code today.  Architecture is going to be there whether we design for it or not.  We can choose to let it happen to us or we can be deliberate about it.  In the old days we had deliberate architecture teams, it was god awful and I don't want to go back to it.  Today it is democratised, which is cool.  It moves us towards being generalists, but with the freedom to create architecture collaboratively and independently, there
is also a lot of responsibility that comes with that.  We need to be the best architects we can be. We can owe it to our stakeholders, our teams and our future selves.  Finding the sculpture in the block of granite and working to help it emerge.  I'm confident that with a bit of changing, a change in our thinking, a little change in our processes be more thoughtful and deliberate, we can create code that is not only functional and timely but elegant, beautiful, something to be proud
of.  Writing code like that makes me happy.  Think what makes you happy.  I'm Coraline Ada
Ehmke, thank you so much for your time and I'm happy to be here today.  Thank you so much.
