Today I thought I might actually talk about service-oriented architecture.  Hi, some of you may not recognise me without my vanity sunglasses, which I unfortunately forgot to bring.  I'm Philip, sometimes affectionately referred to on the Internet as Parnt.  I filled out a form and became a member of Ruby New Zealand and
then filled out another form and people voted.  I live in Christchurch, New Zealand, which is such a beautiful place, as you can see, with a lot of sheep, and Josh.
JOSH KALDERIMIS:  Not cool!
PHILIP ARNDT:  I have been waiting about a day to do this.  Very rewarding.  I have contributed to and maintained a few Ruby gems that everyone is using, right? Not even Emma
Ruby? Some people are anyway.  So today I would like to broach the topic of succeeding with
open source.  What is success? In this presentation I'm going to focus mainly on how open source has helped my career's development and leave ideas like saving the bees to Sean.  Once upon a time in a land far, far away, New Zealand... there existed a group of well-dressed Rubyists, well
at least on suit-up day, I was working with a company called Resolved Digital, my first job, we liked programming but not really manually updating anyone's contents or having anything to do
with anyone's content, so we built an inhouse content system for all our sites.  This is that CMS
which was called M tools from website builder in 2008.  It was surprisingly difficult to find a screen shot of it, but luckily Dave came through.  The problem is what hard to maintain.  Bug fixes were hard to share with other sites, because to reuse it, we just cloned the repository of GitHub and wrote the app on top of it.  Who hasn't done that? We almost replaced it with Raids radiant CMS but users were likely to break the site by putting a tag in the wrong place.  What I'm getting at it wasn't perfect by any stretch but I thought its heart was in the right place.  It just needed a little love to be something great.  But what happened next may shock you.  M tools became refinery CMS, which totally everyone has used? Crickets... but it is now the most
popular open source CMS for Ruby by a pretty good margin.  You might be wondering why would we open source a valuable company asset? Wouldn't all our competitors take it and build
sites and undercut us with our technology? Open source is free, so it can't be about the money.
With M tools it certainly didn't start out that way.  We just thought it was kind of cool and wanted to share it with other people and thought we would get value back but we soon found out our clients liked being sold a stable platform, they liked apparently popular platforms.  And
unfortunately in our society money is pretty important so whether to produce or use open source
is often a very financial decision.  As the Internet has made the world feel much, much smaller it is important to do good work and to sell quality software to our clients.  But what we found is
that some people will want to use your work that you have put out there for free, but others will
want to hire you based on your work.  So in refinery's case, by open sourcing it, we saw three main benefits.  First of all it showed off our work to prospective clients we couldn't reach by simple marketing alone.  It also proved we are experts in creating user-friendly systems and placed the company's logo on the project's website which drove lots of traffic generating lots of new clients.  Other companies made web sites for their customers using refinery and they'd fix many of the bugs that we had somehow gotten in there, don't know how.  There was free benefit provided to us and free benefit provided to our clients.  It is great for goodwill to our clients to prove open source was the way to go rather than some closed source system.  We opened up a new sphere which we weren't expecting which is that people would want to extend it.  People were writing E tensions and sharing them back to us.  We would show it to future clients and say we can do this.  It was a win for us, and a win for our clients.  It was a benefit for our
contributors because they got to use really great software to earn money.  But it has to be said at the beginning of this, relatively new to open source and it was like diving into the deep end of the pool.  So, what have I learned throughout this? Sorry, who is that guy? Let me fix that up for you real quick.  All of these learnings apply to the maintenance of a project.  The first thing that I
have learned is that I definitely get out what I put in. This applies to dealing with both contributors and maintainers that I found, mainly the maintenance one.  I found if I didn't put enough investment into people that are contributing it is not very likely they are going to contribute again.  That is something I want to happen, because I don't want to do all the work.  I learned I have to take contributions seriously and help those who want to contribute.  This means that when they submit a feature or a patch the first thing I do is not close it and say, "Won't fix or won't merge" which may feel familiar from the larger projects which we won't talk about.  It is key because contributors have had to get over a ridiculously large barrier to contribute their patches back to you, barriers including embarrassment or impostor syndrome or any number of things like physical boundaries or financial cost of actually spending their time working on your

open source.  The next thing I learned is that when I write perfect software, when somebody sends me a patch to fix something which is broken, that can make me really upset.  But the contributor probably didn't want to offend me.  So the one thing I have learned is that assuming that people are good people, it is pretty much critical in open source given the many physical and cultural boundaries that exist.  I have to assume they are actually helping me rather than trying to slant me in some ridiculous way.  This ties back to best advice from Jason Fred from Basecamp which is to give it five minutes.  It boils down to don't reply straightaway, close the laptop, walk away and think about it.  What is really going on here? What are they trying to say? Are they trying to offend me with their change or trying to improve things? It is probably the latter.  So I try not to make complicated roadblocks in the way of contributors, try and make it easy for them. If there is some complicated part I can just do that for nem them.  A lot of barriers are unnecessarily barriers.  Git rebase, who has used that before? Don't we love it when it works the first time? Exactly.  Unfortunately it almost never does.  So if you have contributed to open source you have probably seen this before, maybe from me.  I'm sorry.  But after years of experience I like to think that I'm pretty good at doing this by myself.  So I can do this for new contributors, just to say thank you, thank you for contributing your patch, it doesn't merge simply but I will sort it out.  Next time if they for some reason still contribute, I can actually say, do you want me to teach you what I did last time and it seems like magic and it keeps going on and we learn things.  Probably the most important thing I have learned is to try to avoid burnout, which I have come close to.  For a while I thought I had to be this sort of gatekeeper and maintain a perfect code base and nothing should get in without a militant review of mine.  But I have come to realise that when people get interested and show enthusiasm, maybe I want to add them as a contributor.  Maybe I want to give them access to the repository, it probably won't combust. Justin Searles had a good talk about at Ruby in San Diego.  Just watch that.  I will Tweet the link later.  This goes to when I am the contributor to a project, what have I learned then? In most
cases I try to pretend I am the maintainer and submitting the patch to myself.  I ask myself what would I want in this situation? The first thing I am going to want is tests.  And send my
contribution back to them as well.  Just sensible things like that.  Unfortunately a lot of poor
requests won't get merged, no matter how much time we spend on them.  So before doing major changes I learned the hard way to ask if it is even wanted in the first place.  One really good example of this is when I read the Rails contribution guide and I learned that the indentation across Rails repository was supposed to be formatted a particular way, I went through until 10 o'clock at night and thought let's fix this grand injustice of the world.  I used magic, I have no idea how to use Vim, so it wasn't with that and I did it one gem as a time.  This led to interesting discussions by the maintainers and me.  And the result of that may surprise you.  Basically, no
thanks, close.  So this ties into keeping changes very cohesive and very small.  Small changes are very good.  My priority to get something fixed is to get my fix or get it accepted so keeping them small is probably the best way to do tat.  This centres around the idea that changes should be limited to one functional unit or as small as you can possibly get it to get it expressed.  With my maintainer's hat, I wouldn't go to the new better style which looks like JSON.  Reduced complexity with a use case.  Unfortunately we are all opinionated Rubyists with our own style about how hard code should be written, like my rockets infinity or indented, but I found it extremely useful to mirror the existing style that the project already has, or to check the style guide and see whether that mentions how they want it.  This shows basic respect for the maintainer and takes less time to review and results in less going back and forward over minor issues and will probably mean my patch gets merged and I get another green.net.  Existing solutions can appear complex or maybe poorly written but there are many reasons for this.  The author probably isn't a bad programmer but they probably have limited time and they thought the current situation was good enough and just hey, ship it, right? I prefer working tested solutions over perfect code because we can fix it later.  Sorry, pre-factoring doesn't always apply. Maintainers love it when code is improved and just try and be polite when you do it.  Ancient wisdom of Voltar, changes might get something to take my crappy code and make it good.  My solution is going to be a catalyst and that's fine.  I don't need to get my name on every single project.  It just gets the discussion started.  So how is open source helping my career? I see my career in two distinct aspects to be going well, technical success and social success.  How does open source do that for me? Technically I have had to keep pace with updates to other popular libraries like Rails which, believe it or not, changes all the time in interesting ways between minor versions and patch versions, but hey, it is their project.  It has exposed heaps of different styles of programming and it trains my brain to think in new and interesting ways.  In terms of
the social side of things, open source has provided me a gigantic boost there.  GitHub's tag line is social coding and the social aspect that comes from open source is one of the biggest influences on why I do it.  I get to work on cool projects with really nice people.  This may be going a bit

too far, I don't think I'm particularly famous but I've had people walk up to me I've never met before and say, "Hey, you're the refinery guy, right?" Or, "Hey, Philip Punt" which is not my name.  It has led to way better jobs.  It is not what you know but who you know.  Tie that together and you will get pretty interesting jobs.  Some people I don't know have hired me out of the blue just on stuff on GitHub, which is pretty flattering when you think about it.  Work brought to me throughout the open source community have provided me with the opportunity to travel with my wife, who wouldn't send that picture to Josh, to the Northern Hemisphere during
most of 2014 where I went to nine or ten conferences and met tonnes of people, some of who are here today.  I wouldn't be here speaking to you today.  Funny how it works.  So let me bring this
to a close.  It was really scary, honestly scary to get my first project out there and to start with open source with refinery, even though it was something we all knew about.  Impostor syndrome
is definitely a thing and I felt like, hey, let's just do it anyway and get over it.  If I hadn't done that
I would have missed out going to the first New Zealand Rails camp, which pretty cool story, contributors and other people who used refinery paid for my ticket and flight to get to that when I
told them I wanted to go.  I wouldn't have met a lot of the cool people in Christchurch or New
Zealand and it would have lost me so many cool friends, some of whom are here today.  It would have meant I would have way fewer travel and conference opportunities.  While it was scary, the benefit is totally worth the cost.  If you are maybe on the brink of starting a project or contributing to a project you should just do it.  So this brings me to my thanks.  This presentation would have been lots harder without the support of friends I actually only know through open source.  The first of which is Jim.  He is the maintainer of radiant CMS.  The thing we could
have used but didn't.  He is a great guy and understands.  And Rob, helped me with the content and the flow of this talk.  To all of you guys for listening.  Thanks.
