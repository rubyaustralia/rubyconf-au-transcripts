So, this talk is about how our team at Song Kick changed the culture. We are going to go through the lessons we have learned and our approach to that project.  Then I'm going to show you some code and how we implemented the changes and then I will use the "A" word, but don't fear, and then I will talk about how it changed our company's culture and how we work.  I work for Song Kick, this is a story about it, we are a company that helps fans go to more concerts.  We launched a new version of the website back in 2009.  In the following years we were happily building new features, experimenting with the product and it was very exciting.  Over time we realised it was taking longer and longer to release new features.  So you don't have to see this, this is a graph, a great visual position we were in.  Change to the lines, we need to make sure we didn't break the projects that were depending on it.  It was very hard to

make climate changes.  It was basically hell.  So, yes, no improvements to the code bus weren't cutting it any more.  Something drastic had to change.  So we made a decision, which is quite popular nowadays but not so much when we did it, a hipster architecture, because I'm from east London, so the decision was to go to service-oriented architecture and splitting the domain services and each product having front and back end using those services.  It has been over three years since we made that decision and we are much more productive nowadays.  I will share some of the lessons of finishing a project like this.  So the first one is to know your product. Some time before the rewrite project started the product team was working hard to find out what our main proposition was.  We had a bunch of features related to live music that we built over
the years but we wanted to find out the main reason users came back.  After a lot of user research, we found out that it was to track their favourite artists so they never missed them live. The most important feature is to have all the events around the world, so we be notify users about them and they can buy tickets.  So we built an iPhone app based on this proposition and it was a big success from the start and still is.  We knew what our product was.  We knew that we wanted to go from here, to here, a lovely sunny end state, this is a diagram we drew at the time of what
we wanted the future to look like.  As Coraline said yesterday, if you don't have your model, service-oriented architecture will break up your code and add latency and make you slower, which is so true.  But we understood our products and other domain model so we knew what the end result looked like.  But we got to start somewhere, we are not just going to arrive at this lovely destination.  How do you know where to start? We decided to start with what hurt the most, it was the best place to start for our company.  Because a rewrite is a very risky project, it makes sense to start where you see the most benefits the quickest.  So this was our end goal for the rewrite project.  We wanted to iterate quickly on the website, so a Rails application.  So we started there by pushing the complexity down and hiding behind Ruby service classes.  This would give us the opportunity to understand the resources and the API end points we needed so we can use the knowledge to built the HTP services.  As you can see, we weren't trying to change everything at the same time.  At the end, we still have the Rails app in a sunny, happy state,
where we can make changes quickly.  But we would also have the legacy code and a couple of projects below that.  That's fine.  Related to that, one thing we learned is that it is really
important to have one specific goal for your rewrite project.  We knew if we simplified, it was is
the goal at the time, if we simplified the website, users wouldn't go away.  We weren't making changes just for them, improving the velocity was the main reason.  The possibility of starting over is very exciting.  It is really tempting to try to work on everyone's favourite features and
issues and problems and try new technologies and doing everything perfect and new and
thinking that this time we'll get everything right.  But this lack of focus makes it very difficult to finish a project like this.  Having one goal in mind made it easier for us to focus and reject
unrelated changes.  So this lesson was very hard for us to learn, which was to have an explicit -
to define the full project scope and have a clear deadline.  What we ended up doing was writing down every feature we wanted to keep, estimated how long it would take and figured out it would take longer than we could afford.  So we went back and removed features until we had a manageable deadline.  We would check that deadline every week and make sure we were on schedule and delete more features if we needed.  For us at the time, having a new feature was less valuable than moving fast again.  So during that project we didn't add any new features. Until we were finished it was rewriting or deleting.  Speaking of deleting, it is faster than rewriting.  We analysed how features were used but had input by the development team which areas were hard to maintain.  It was hard to delete features I liked a lot but I am not an average user.  So knowing your product gives you the confidence of knowing what is okay to delete without scaring your users away.  Another decision we made was to rewrite the application and not restart it, rewrite it on the same project we had and releases as we progressed.  We would pick a page at a time, rewrite it completely and release it.  I am going to talk about the new architecture, that is the "A" word, and we moved towards continuous delivery.  A shout-out to Joseph Wilk who is here, he worked at Song Kick at the time.  He was the biggest advocate for delivery, so thank you, Joe.  Another lesson was to iterate, when you are used to a slow release process, it is hard to learn that you can go faster.  So when we started the project we were progressing slowly.  Every change had to be manually tested and every small decision on copy and design had to be reviewed by the project manager or a designer.  So we had to realise that a release cycle is more than software development and we needed to make changes more than just to our code.  One way that we found to reduce this bottleneck was to give developers more responsibility about testing their own code and making decisions about copy and design.  If we give developers the right context and trust them, you can trust them to make the right decisions and own the code and product quality.  So those are the lessons.  I am going to talk a bit about our new front end architecture, not so new any more.  It allowed us to iterate quickly where we

needed it the most.  I promise myself I would add to the presentation because they are one of my favourite bands and they are from Melbourne and they were playing just before the break, so it was kind of a sign for me.  This is the event page for the last concert.  It was an iterative process. We would pick our most popular pages first, in this case the event page, and the developers who were rewriting it would get together with product managers and designers.  So the component for us is discreet functionality on the page and you can see the pink names.  They function with other components.  At the same time we would remove or simplify complex features on that page.  So this is a pretty straightforward Rails app.  It looks good.  So I will talk about a couple of new modules we have created in the new architecture in relation to the event page and the one at the top.  So the way we rewrite it is starting with a controller, just simplify it a lot.  All the action it was doing is associating a new page model, which is the Ruby class representation for that page
or that template.  The page model itself has methods to create its components and get the data
into the display or the actions it needs to perform.  Here is a brief component.  As you can see, by default, the component belongs to one page.  One thing that we decided is that if we are building
a new page, it needs a component.  Unless it behaves and looks exactly like one we already have,
we would create a new component.  We were very happy to that have duplication in the front-end code if it means less statements and checks and reviews and less override.  This has reduced the number of presentation bugs we have.  Again you can see the consistent names with the file names on the SCC classes and Ruby classes.  They have the names of the images or the component of the page.  By defining those components and pages together with designers and product managers, what we created was a shared language that was used from the idea to the
code base.  This means that we have a shared understanding of what we are building.  It makes it easier to talk about things.  It sounds simple but it is really powerful.  This consistency of naming
makes it easier for a developer or someone with the code base to find their way around the code.
If someone says there is a bug in the event brief, even if I don't know where it is, I can expect to find something like that in the code base.  A fast release cycle, so the bill used to take a long time.  You delete tests.  So, the only end-to-end integration tests we kept were the ones that our tester and product owner picked.  They decided that would give them enough confidence that we wouldn't break Song Kick's main proposition.  All the others were rewritten as unit tests or deleted.  A slow build discourages refactoring.  The cost of making small changes is very small and we can keep refactoring and improving the code base.  To cope with the risk of having to retest we set up error logging and monitoring.  So we get alerts when error spikes happen and a daily error email we get and we try to keep on top of those.  At the same time we were rewriting that, our controllers and end users were trying to go through our first service to our
service-oriented architecture.  So if we had this, called event, we would replace it with a specific client model and they got the data they needed to associate itself.  This service class was the only
one that was allowed to talk to active record models and the active record would define a model
that would set the data that would return.  It meant we can easily change how the services and methods and the data it returned, because they were in the same code base, we would rate services until we got it right.  At the same time we had benefits of catching what would become the service client code.  The same API, we can replace it and finish the coupling.  Which we did. After three months we had a decoupled rewritten Rails app, the users world still there.  It had immediate benefit to the velocity.  You can see the spike of releases and the spike of happiness. So I will talk about the cultural changes.  During the month we were working closer together with designers and product managers to help each other to finish it as quick as we could because
no-one wanted to stay there long.  We changed our culture.  We had a better understanding of the process and puzzle.  We felt more comfortable suggesting solutions and designers and product
managers understood the risks of implementing the products.  So the culture and practice, our
culture is translated to our process so I spoke about our shared language, our small releases and how we favoured iterating over product design.  Here are two more examples of how it changed the way we worked.  So we used to have features that were fully formed, delivered to the developers, the product manager and the designer would think about it and define it after weeks of discussion and tell the developer, "Just build this".  Now we try to bring there developers earlier in the process and give feedback early on.  Features are defined during what we call
kick-off meeting with developers, product managers, testers and everyone involved.  That allows for everyone to raise questions and collaborate and define what it is we are trying to build and
understand why we are trying to build it.  The other thing that made a change in our process is
instead of getting files, we have developers and designers pairing.  Developers are happy because we give feedback happy and designers are happy because it gives an understanding of the code base and what is possible to achieve.  It encourages the team to get involved with the way the product looks and feels.  I think that is most of what I had to say.  But to finish it off, having a clean code base is a means to an end.  If you have a perfect architecture but if it is for no-one it

doesn't matter.  The reason we do is to deliver products to end users, collaborate and work in a multi disciplinary team, get closer to the product and the business teams of your company.  Help them understand how you work and what is important to you, but also learn how they work and what is important to them.  Having a better understanding of how your work fits with others can help you do your own much better.  For us, working in a multi-disciplinary team made us happier and we were delivering better products and improved the code quality in the process.  So I recommend you try it out.  Yes, there is lots more I can talk about this, come talk to me afterwards.  Thank you so much for having me, it has been great.  Thank you.
